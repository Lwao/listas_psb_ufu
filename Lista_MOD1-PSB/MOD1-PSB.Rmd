
---
title: "Lista do Módulo 1"
author: "Levy Gabriel da Silva Galvão"
output: 
  html_document:
    toc: true
    highlight: tango
    includes:
      after_body: psbfix.html
---

# Módulo 1
## Parte 1
### Exercício 1
> Crie uma função em R para fazer a conversão entre unidades de temperatura (De Kelvin para Celcius). Forneça um exemplo de uso.

```{r}
kelvin2celsius <- function(temp_kelvin)
{
  temp_celsius <- temp_kelvin - 273.15
  return(temp_celsius)
}
```

Um exemplo para este caso é encontrar a temperatura padrão das condições normais de temperatura e pressão (CNTP) de 273.15 K em Celsius, resultando em:

```{r}
cntp_kelvin <- 273.15
cntp_celsius <- kelvin2celsius(cntp_kelvin)
print(cntp_celsius)
```

### Exercício 2
> Crie um loop que imprima os valores ímpares no intervalo de 1 a 100.

```{r}
num <- 0
for(num in 1:100)
{
  if(num %% 2) # if number is odd
  {
    print(num)
  }
}
```
### Exercício 3
> Qual a diferença entre os operadores “&”, “&&”, “|” e “||”. Ilustre o uso destes operadores por meio de um programa exemplo.
resposta

Os operadores simples "&" e "|" atuam realizando a operação elemento a elemento (*element wise*) entre seus operandos, enquanto que os operadores "&&" e "||" executam a operação em um único elemento e, se utilizado entre *arrays*, a operação será feita somente no primeiro elemento. Vide exemplo abaixo.

```{r}
# test arrays
x <- c(FALSE, FALSE, TRUE, TRUE)
y <- c(FALSE, TRUE, FALSE, TRUE)
# element wise operation
print(x&y)
print(x|y)
# single element operation
print(x&&y)
print(x||y)
```
Pela distribuição dos *arrays*, permite-se traçar as tabelas verdades da operação AND por meio do operador "&" e da operação OR por meio do operador "|", enquanto que como o esperado os operadores duplos atuam somente nos primeiros elementos.

### Exercício 4
> Faça um programa que exemplifique o uso do operador “%in%”

O operador "%in%" verifica se o conteúdo do *array* como primeiro operando está contido no *array* como segundo operando. O retorno é um *array* binário que pode ser usado para indexar todo o conteúdo do primeiro operando que está contido no segundo operando. Vide os exemplos abaixo.

```{r}
x <- c(0, 2, 4, 6)
y <- 1:10
# boolean array that indicates whether content of first operand is in the second operand
print(x%in%y)
# this result can be used to index all the content from the first operand that meets the requirements
print(x[x%in%y])
```
### Exercício 5
> Dado a string “O Sol é muito maior do que a Terra”, faça um programa que:

- Substitua a palavra “Terra” por “Lua”
- Conte o número de caracteres da string original e da string alterada;
- Ordene a string alterada
- Faça uma comparação usando o operador & entre a string alterada e original.
- Explique o resultado obtido.
- Utilize o operador == para identificar os caracteres iguais.

O primeiro passo é substituir o trecho "Terra" da *string* por "Lua", resultando em (com o auxílio da biblioteca **stringr**):

```{r}
library(stringr) # library to handle strings
str_ <- "O Sol é muito maior do que a Terra"
str_new <- str_replace(str_, "Terra", "Lua")
print(str_new)
```
Assim, o número de caracteres da *string* original será:

```{r}
print(str_length(str_))
```

E da *string* modificada:

```{r}
print(str_length(str_new))
```
Assim, mostrando que, uma vez que a palavra inserida "Lua" np lugar de "Terra" por ter uma quantidade de caracteres menor, permitiu que a nova *string* modificada possua, também, menos caracteres.

O próximo passo é ordenar os caracteres da *string* modificada, resultando em:

```{r}
str_splited = unlist(strsplit(str_new, "")) # split string to get characters
str_sorted <- str_sort(str_splited) # sorting in ascending order
str_merged <- str_c(str_sorted, collapse="")
print(str_merged)
```

O passo seguinte é comparar a *string* alterada com a original com meio do operador "&" elemento a elemento.

```{r, error=TRUE}
print(str_merged & str_new)
```
A operação AND elemento a elemento não é definida para *strings* ou caracteres, por isso o erro persiste.

Porém a comparação de igualdade "==" existe e, por meio do vetor de caracteres, pode-se definir um vetor comparando quais caracteres são iguais.

```{r}
print(unlist(strsplit(str_new, "")) == unlist(strsplit(str_, "")))
```
Apesar das *strings* diferirem no tamanho (a nova *string* é menor), a operação de igualdade ainda é feita, porém com um aviso. O vetor booleano resultante possuirá o tamanho da maior *string* e os últimos elementos que não existem na *string* menor serão preenchidos com FALSE.


### Exercício 6
> Refaça todos os exemplos apresentados neste módulo Parte 1.

```{r}
meuTexto <- "Bom dia!" # com comentarios para teste
print(meuTexto)
```

```{r}
class(meuTexto)
```

```{r}
v <- 100
class(v)
```

```{r}
v <- "100"
class(v)
```

```{r}
v <- F
class(v)
```

```{r}
v <- 100L 
class(v)
```

```{r}
v <- 6 + 8i
class(v)
```

```{r}
minhaVariavel <- 1
m_var <- 1
.mvar <- 1 # hiden object
```

```{r}
x <- 100 # 100 stored in x
print(x)
y <- 200 + 300 # 100 stored in y
print(y)
z <- x + y 
print(z)
100 -> x # works fine as in x <- 100
v_cor <- c('azul', 'amarelo', 'rosa')
print(v_cor)
v01 <- c(3,4,5)
print(v01)
```

```{r}
cat(v01) # print on screen or file
```

```{r}
ls() # show variables
```

```{r}
ls(pattern = "v") # variables with char v
```

```{r, error=TRUE}
meuTexto <- "texto"
rm(meuTexto) # remove variable from workspace
print(meuTexto)
```

```{r}
a1 <- c(9, 0, -4)
a2 <- c(8, 2, -1)

print(a1 + a2) # sum

s1 <<- c(1, 2, 3)
c(4, 5, 2) ->> s2

print(s1-s2) # subtraction

m1 <- c(2, 5, 8)
m2 <- c(3, 6, 9)
print(m1*m2) # multiplication

d1 <- c(6,8,9)
d2 <- c(2,4,3)
print(d1/d2) # division

r1 <- c(10, 13, 19)
r2 <- c(3, 4, 5)
print(r1%%r2) # module operation

r1 <- c(10, 13, 19)
r2 <- c(3, 4, 5)
print(r1 %/% r2) # division quocient

e1 <- c(2, 3, 4)
e2 <- c(3, 2, 2)
print(e1^e2) # exponenciation

g1 <- c(6,8,9)
g2 <- c(9,2,6)
print(g1>g2) # greather then

g1 <- c(6, 8, 9)
g2 <- c(9,2, 6)
print(g1<g2) # less then

e1 <- c(3, 6, 9)
e2 <- c(2, 7, 9)
print(e1==e2) # equal

e1 <- c(3, 6, 9)
e2 <- c(2, 7, 9)
print(e1 >= e2) # greather then and equal

e1 <- c(3, 6, 9)
e2 <- c(2, 7, 9)
print(e1 <= e2) # less then and equal

e1 <- c(3, 6, 9)
e2 <- c(2, 7, 9)

print(e1!=e2) # different

x <- c(TRUE,FALSE,0,6)
y <- c(FALSE,TRUE,FALSE,TRUE)

print(!x) # element wise NOT
print(x&y) # element wise AND 
print(x&&y) # AND in first element
print(x|y) # element wise OR
print(x||y) # OR in first element

v <- 1:8 
print(v) # range
```

```{r}
1:3==1:3 && 1:3==1:3
```

```{r}
x <- 1:5
x[x<5]
```

```{r}
x[x<5 & x>2]
```

```{r}
x[x<5 && x>2]
```

```{r}
v1 <- 6
v2 <- 15
m <- 1:8

print(v1 %in% m) # is in
print(v2 %in% m) # is in
```

```{r}
x <- 1:10
print(x)
y <- c(1,3:11)
print(y)
```

```{r}
x[x%in%y]
```

```{r}
y[y%in%x]
```

```{r}
y[x%in%y] # wrong indexing
```

```{r}
m <- 200
n <- 100

if(m>n){ # if
  print("m é maior do que n")
}
```

```{r}
m <- 200
n <- 100

if(m<n){ # if then else
  print("m é menor do que n")
} else {
  print("m é maior do que n")
}
```

```{r}
#switch

var <- "vegetal"

switch(var,
       fruit = "maçã",
       vegetal = "espinafre",
       carne = "frango")
```

```{r}
# repeat
var <- c("Very Good!")
num <- 0

repeat{
  print(var)
  num <- num + 1
  if(num > 5){
    
    break # para o loop
  }
}
```

```{r}
#while

var <- c("OLA")
num <- 0

while(num<5){
  print(var)
  num <- num + 1
}
```

```{r}
#for

var <- c(1:5)

for(num in var)
{
  print("ola")
  
}
```

```{r}
#for

var <- c(1:5)

for(num in var)
{
  print("ola")
  
}
```

```{r}
# function

myfunction <- function(x,y)
{
  num <- x + y
  return(num)
  
}

a <- myfunction(100, 200)
print(a)
```

```{r}
myfunction <- function(x,y)
{
  num <- 300 + 400
  return(num)
  
}

a <- myfunction()
print(a)
```

```{r}
myfunction <- function(x=3,y=5)
{
  num <- x + y
  return(num)
}

a <- myfunction()
print(a)
```

```{r}
print(sum(200, 100))
print(abs(-1000))
print(max(100, 200))
print(min(100, 200))
print(sqrt(81))
```

```{r}
num <- c(2, 8, 5, 9, 3)
print(sort(num))
```

```{r}
library(stringr) # calling library
```

```{r}
x <- c("why", "video", "cross", "extra", "deal", "authority")
str_length(x)
```

```{r}
str_c(x, collapse = ", ")
```

```{r}
str_sub(x, start = 1, end = 2)
```

```{r}
m_str <- format(100)
print(m_str)
```

```{r}
# str cat
a <- "R"
b <- "em"
c <- "8"
d <- "horas"

str_c(a,b, sep = " ")
```

```{r}
paste(a,b,c,d)
```

```{r}
str <- "Engenharia Biomédica - UFU"
str_length(str)
```

```{r}
str <- "ENGENHARIA BIOMÉDICA - UFU"
str_to_lower(str)
```

```{r}
str <- "engenharia biomédica - ufu"
str_to_upper(str)
```

```{r}
str <- "engenharia biomédica - ufu"
str_to_title(str)
```

```{r}
str <- "engenharia biomédica - ufu"
str_replace(str,'ufu', "UFU")
```

## Parte 2
### Exercício 7
> Refaça todos os exemplos apresentados neste módulo Parte 2.


```{r}
# integer vector
v.inteiro <- integer(10)
v.inteiro <- c(1:10)

# double vector
v.double <- numeric(10)
v.double <- c(2.5, c(1:9))

# logical vector
v.logical <- logical(10)
v.logical <- c(F, T, F, F, T, F, T, T, T, F)

# complex vector
v.complex <- complex(10)
v.complex <- c(1+2i, 3+1i, 5-4i, 9-0.1i, 10-54i,
               100-1i, -2-2i, 3+3i, 10-0i, 8)

# raw vector
v.raw <- raw(length = 5) 
rawToChar(v.raw)
```

```{r}
v.raw[1] <- as.raw(10)
rawToChar(v.raw[1])
```

```{r}
v.raw[2] <- as.raw(5)
rawToChar(v.raw[2])
```

```{r}
print("céu azul") # vector of chars
print("98.1") # double
print(2:8) # integer vector
print(1.8:6.8) # double vector
print (c(3,4,5)) # also integer vector
print(c("apple", "banana", "cherry")) # string vector
```

```{r}
seq(from = 1, to=2, by = 0.1) # ranging vector
```

```{r, error=TRUE}
v1 <- seq(from=0, to=2, by =0.1) 
print(v1)
print(v1[1])
print(v1[c(1, 4)])
v2 <- c("maçã", "banana", "amora")
print(v2[2])
print(v2[c(1, 3)])
v3 <- c("maçã", "banana", "amora")
print(v3[c(FALSE, TRUE, FALSE)]) # only true values are displayed
v2 <- c("maçã", "banana", "amora")
print(v2)
print(v2[-2]) # removing second element

v1 <- c(1, 2, 3)
v2 <- c(4, 5, 6)

print(v1 + v2) # vector sum
print(v1 - v2) # vector sub
print(v1 * v2) # vector mul
print(v1/v2) # vector div

v1 <- c(4,5,6,7,8,9)
v2 <- c(2,3)
r <- v1 + v2

print(r)print(v2 - v1)

v<-c(1:10)
print(sort(v, decreasing = TRUE))
a<-seq(from=-1, to=1, by = 0.1)
print(sort(a, decreasing = FALSE))
ml <- list("a", "b", "c", "d")
print(ml)
print(ml[2])
ml[5] <- 45.67
print(ml)
ml[5] <- NULL
print(ml)
ml[2] <- "atualizei o segundo elemento"
print(ml[2])
l1 <- list("a", "b", 2)
l2 <- list("d", "e", 3)
l12  <- c(l1, l2)
print(l12)
v12 <- unlist(l12)
print(v12)

v <- c(1:12)
vnames <- list( 
  c("row1", "row2"), # row names
  c("col1", "col2", "col3","col4","col5","col6")) # column names

m <- matrix(v, nrow = 2, ncol = 6, byrow = TRUE, dimnames = vnames)

print(m)

m <- matrix(v, nrow = 2, ncol = 6, byrow = FALSE, dimnames = vnames)

print(m)
print(m[2,3])
print(m[1,3])
print(m[2,6])
print(m[1,4])

m2 <- matrix(c(4,5,6,7,8,9), nrow = 2)
print(m2)

print(m2 + m2)
print(m2 - m2)
print(m2 * m2) 
print(m2/3*m2) 

rownames <- c("r1", "r2", "r3")
colnames <- c("c1", "c2", "c3",  "c4")

m1 <- matrix(c(1:12), nrow = 3, ncol = 4, dimnames = list(rownames, colnames))

print(m1)

M1 = matrix(c(46,  41,  85,  94,  10,  21,  27,  39,  89), nrow = 3)

M2 = matrix(c(26,  54,  39,  32,  62,  85,  19,  57,  38), nrow = 3)

## multiplication
M_prod = M1 %*% M2

print(M_prod); cat("\n")

M_transp = t(M1)

print(M_transp); cat("\n")
```

```{r}
M1 = matrix(c(46,  41,  85,  94,  10,  21,  27,  39,  89), nrow = 3)
M2 = matrix(c(26,  54,  39,  32,  62,  85,  19,  57,  38), nrow = 3)
det(M1) # determinant of matrix
```

```{r}
M_inversa = solve(M1)

print(M_inversa); cat("\n")
```

```{r}
solve(M1)%*%M1
```

```{r}
sum(diag(M1))
```

```{r}
crossprod(M1,M2)   # M1'M2
```

```{r}
kronecker(M1, M2)
```

```{r}
print(array(1:8))
print(array(1:8, dim = c(2,4)))
print(array(1:16, dim = c(2,4,2))) 

rowname <- c("r1", "r2", "r3")
colname <- c("c1", "c2", "c3")
matrixname <- c("m1", "m2")

marray <- array(1:18, dim = c(3,3,2),
                dimnames = list(rowname, 
                                colname,
                                matrixname))

print(marray)

print( marray[2, 3 ,1] )
print(marray[,,1])
print(marray[2,,1])

vector1 <- c(1,2,3)
vector2 <- c(4,5,6,7,8,9)

marray <- array(c(vector1, vector2),
                dim = c(3,3,1))

print(marray)

result1 <- apply(marray, c(1), sum)
print(result1)
```

```{r}
result2 <- apply(marray, c(2), sum)
apply(marray, c(3), sum)
```

```{r}
result3 <- apply(marray, c(3), sort)
print(result3)
myfactor <- factor(1:5, levels=1:8, labels = c("a"))
print(myfactor)
data <- c("A", "C", "B", "B", "C", "A")
myfactor <- factor(data)
print(myfactor)
myfactor <- factor(1:5, levels = 1:3,
                   labels=c("a", "b", "c"))

print(myfactor)
data <- c("A", "C", "B", "B", "C", "A")
myfactor <- factor(data, labels=c("maçã", "banana", "uva"))
print(myfactor)
myfactor <- factor(c("A", "B","C"),
                   levels = c("C", "B", "A"))
print(myfactor)
L <- gl(4,2, labels = c("A", "B", "C", "D"))
print(L)
L <- gl(4,5, labels = c("A", "B", "C", "D"))
print(L)
```

```{r}
sex <- factor(c("male", "female", "female", "male"))

levels(sex)
```

```{r}
nlevels(sex)
```

```{r}
food <- factor(c("low", "high", "medium", "high", "low", "medium", "high"))
levels(food)
```

```{r}
food <- factor(food, levels = c("low", "medium", "high"))
levels(food)
```

```{r}
food <- factor(food, levels = c("low", "medium", "high"), ordered = TRUE)
levels(food)
```

```{r}
exercise <- factor(c("l", "n", "n", "i", "l"), levels = c("n", "l", "i"), ordered = TRUE)
print(exercise)
```

```{r}
df <- data.frame(
  id = c(1:5),
  name = c("Silvana", "João", "Maria", "Roberto", "Carla"),
  score = c(85,99,95,92,96),
  year = c("2009", "2002", "2008", "2006", "2007"),
  stringsAsFactors = FALSE
)

print(df)
```

```{r}
str(df)
```

```{r}
summary(df)
```

```{r}
print(df$id)
print(df$name)
print(df$score)
print(df$year)

df$idade <- c(30,40,17,12,98)
print(df)

newRows <- data.frame(
  
  id = c(6,7),
  name = c("Rui", "Alana"),
  score = c(100, 33),
  year = c("1999", "1997"),
  idade = c(43, 33),
  stringsAsFactors = FALSE
  
)

df <- rbind(df, newRows)
print(df)

id <- c("001", "002", "003", "004")
name <- c("Anna", "Judy", "Tony", "Nacy")
age <- c(18, 16, 20, 19)

members <- cbind(id, name,age)
print(members)
```

```{r}
library(dplyr)
library(nycflights13)
dim(flights)
```

```{r}
str(flights)
```

```{r}
filter(flights, month == 1, day == 1)
```

```{r}
arrange(flights, dep_time, day, month, year)
```

```{r}
arrange(flights, dep_time, desc(day), month, year)
```

```{r}
select(flights, year, month, day)
```

```{r}
rename(flights, tail_num = tailnum)
```


```{r}
mutate(flights,
  gain = arr_delay - dep_delay,
  speed = distance / air_time * 60
)
```

```{r}
transmute(flights,
  gain = arr_delay - dep_delay,
  gain_per_hour = gain / (air_time / 60)
)
```

```{r}
summarise(flights,
  delay = mean(dep_delay, na.rm = TRUE)
)
```

```{r}
sample_n(flights, 10)
```

```{r}
sample_frac(flights, 0.01)
```

```{r}
by_tailnum <- group_by(flights, tailnum) 

delay <- summarise(by_tailnum, 
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE))

delay <- filter(delay, count > 20, dist < 2000) 

daily <- group_by(flights, year, month, day)
(per_day   <- summarise(daily, flights = n()))
```

```{r}
select(flights, year)
```

```{r}
select(flights, 1)
```

```{r}
select(flights, starts_with("dep"))
```

```{r}
# Piping
a1 <- group_by(flights, year, month, day)
a2 <- select(a1, arr_delay, dep_delay)
a3 <- summarise(a2,
  arr = mean(arr_delay, na.rm = TRUE),
  dep = mean(dep_delay, na.rm = TRUE))
a4 <- filter(a3, arr > 30 | dep > 30)

# or...
flights %>%
  group_by(year, month, day) %>%
  select(arr_delay, dep_delay) %>%
  summarise(
    arr = mean(arr_delay, na.rm = TRUE),
    dep = mean(dep_delay, na.rm = TRUE)
  ) %>%
  filter(arr > 30 | dep > 30)
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```


```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

```{r}
```

### Exercício 8
> Faça um programa em R que avalie o nível de atividade física dos estudantes da disciplina de Processamento de Sinais Biomédicos.

As seguintes variáveis devem ser consideradas:

- Identificador do participante (id)
- Curso do participante (cp)
- Período do curso (pc)
- Idade (idade)
- Peso (peso)
- Altura (altura)
- Nível de atividade física (nat)
  - nat = “nula” - nenhuma vez por semana
  - nat = “baixa” - de uma a duas vezes por semana
  - nat = “moderada” - três a cinco vezes por semana
  - nat = “avançada” - acima de cinco vezes por semana

> Construa um data frame que armazene as variáveis coletadas e faça os seguintes cálculos:

- Número de participantes por cada uma das categorias de nível de atividade fisica (nat)
- Percentual de participantes por cada uma das categorias de nível de atividade fisica (nat)
- Valor médios das variáveis: idade, peso e altura (calcular os valores médios globais, por período de curso e por curso)

```{r}
library(dplyr)
df <- data.frame( # it was used generic data
  id = 1:5,
  cp = c("curso 1", "curso 1", "curso 2", "curso 1", "curso 2"),
  pc = c(5, 2, 4, 9, 9),
  peso = c(40, 80, 90, 50, 60),
  idade = c(20, 22, 21, 19, 18),
  altura = c(180, 129, 160, 170, 180),
  nat = c("avançada", "nula", "nula", "moderada", "baixa")
)
```
Segue abaixo o número de participantes por cada nível de atividade física:

```{r}
partPerNat <- df %>% count(nat)
print(partPerNat)
```

Agora o dado anterior com a opção em formato percentual inserida:

```{r}
numberOfParticipants <- sum(partPerNat$n)
partPerNat$percentual <- partPerNat$n * (100/numberOfParticipants)
print(partPerNat)
```

O próximo passo é calcular a média dos valores numéricos peso, idade e altura do *data frame* para várias situações diferentes. Será utilizado o vetor abaixo para indexar as colunas desejadas:


```{r}
idxCol <- c("peso", "idade", "altura") # selected columns
```

A primeira consiste nos valoes médios globais, resultando em:

```{r}
df_globalMean <- colMeans(df[idxCol], na.rm=TRUE)
print(df_globalMean)
```

Outro quesito é realizar a média baseados em valores filtrados por período de curso, resultando em (nesse caso será exemplificado considerando o nono período):

```{r}
selectedPeriod <- 9
df_sortedByPeriod <- df %>% filter(pc == selectedPeriod) 
df_periodMean <- colMeans(df_sortedByPeriod[idxCol], na.rm=TRUE)
print(df_periodMean)
```


Por fim, filtrando por curso (nesse caso será exemplificado considerando o curso 1):

```{r}
selectedCourse <- "curso 1"
df_sortedByCourse <- df %>% filter(cp == selectedCourse) 
df_courseMean <- colMeans(df_sortedByCourse[idxCol], na.rm=TRUE)
print(df_courseMean)
```

## Parte 3
### Exercício 9
> Faça o tutorial sobre o package dplyr disponível em https://www.listendata.com/2016/08/dplyr-tutorial.html

### Exercício 10
> Faça o tutorial sobre o package stringr disponível em https://cran.rstudio.com/web/packages/stringr/vignettes/stringr.html

### Exercício 11
> Faça novamente o exercício 8 da Parte 2, utilizando a biblioteca dplyr